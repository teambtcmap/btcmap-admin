{% extends "base.html" %}

{% block title %}Add Area{% endblock %}

{% block content %}
<div class="container">
    <div class="d-flex justify-content-between align-items-start mt-5 mb-4">
        <div>
            <h1 class="mb-0" id="add-new-area">Add New Area</h1>
            <p class="mb-0" id="sugestions"></p>
            {% if template_area %}
            <p class="text-muted mb-0">Using deleted area "{{ template_area.tags.get('name', 'Unknown') }}" as template</p>
            {% endif %}
        </div>
        <div class="position-relative area-icon-container">
            <div id="icon-placeholder" class="d-flex align-items-center justify-content-center bg-light border" style="width: 80px; height: 80px; cursor: pointer;" data-bs-toggle="modal" data-bs-target="#editIconModal">
                <span id="icon-placeholder-text" class="text-muted text-center" style="font-size: 0.7rem;">Click to<br>add icon</span>
                <img id="icon-preview-display" style="display: none; width: 100%; height: 100%; object-fit: contain;">
            </div>
            <button type="button" class="btn btn-sm btn-primary position-absolute edit-icon-btn" style="bottom: -8px; right: -8px; padding: 2px 6px; font-size: 0.7rem;" data-bs-toggle="modal" data-bs-target="#editIconModal">
                Edit
            </button>
        </div>
    </div>

    <!-- Edit Icon Modal -->
    <div class="modal fade" id="editIconModal" tabindex="-1" aria-labelledby="editIconModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editIconModalLabel">Set Area Icon</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="iconFileInput" class="form-label">Upload Image</label>
                        <input type="file" class="form-control" id="iconFileInput" accept="image/png,image/jpeg,image/webp,image/svg+xml">
                        <div class="form-text">Accepted formats: PNG, JPG, WebP, SVG. The image will be cropped to a square.</div>
                    </div>

                    <!-- Load from URL option -->
                    <div class="mb-3">
                        <label for="iconUrlInput" class="form-label">Or Load from URL</label>
                        <div class="input-group">
                            <input type="url" class="form-control" id="iconUrlInput" placeholder="https://example.com/image.png">
                            <button type="button" class="btn btn-outline-secondary" id="loadIconUrlBtn">Load</button>
                        </div>
                        <div class="form-text">Enter an image URL to load and edit.</div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Resolution Requirements</label>
                        <div class="form-text">
                            <strong>Minimum:</strong> 128 x 128 pixels<br>
                            <strong>Maximum:</strong> 1024 x 1024 pixels<br>
                            <strong>Output:</strong> Square image (1:1 aspect ratio)
                        </div>
                    </div>

                    <!-- Cropper Container -->
                    <div id="cropperContainer" class="mb-3" style="display: none;">
                        <label class="form-label">Crop Image (drag to pan, scroll to zoom)</label>
                        <div style="max-height: 400px; overflow: hidden;">
                            <img id="cropperImage" style="max-width: 100%;">
                        </div>
                    </div>

                    <!-- Preview -->
                    <div id="previewContainer" class="mb-3" style="display: none;">
                        <label class="form-label">Preview</label>
                        <div class="d-flex align-items-center gap-3">
                            <div>
                                <img id="iconPreview" style="width: 80px; height: 80px; object-fit: cover; border: 1px solid #dee2e6;">
                                <div class="form-text text-center">80px</div>
                            </div>
                            <div>
                                <img id="iconPreviewLarge" style="width: 128px; height: 128px; object-fit: cover; border: 1px solid #dee2e6;">
                                <div class="form-text text-center">128px</div>
                            </div>
                        </div>
                    </div>

                    <!-- Dimension Info -->
                    <div id="dimensionInfo" class="alert alert-info" style="display: none;">
                        <span id="dimensionText"></span>
                    </div>

                    <!-- Error Message -->
                    <div id="iconError" class="alert alert-danger" style="display: none;"></div>

                    <!-- Note about upload timing -->
                    <div class="alert alert-warning">
                        <strong>Note:</strong> The icon will be uploaded after the area is created.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="removeIconBtn" style="display: none;">Remove Icon</button>
                    <button type="button" class="btn btn-primary" id="confirmIconBtn" disabled>Confirm Icon</button>
                </div>
            </div>
        </div>
    </div>
    
    {% include 'components/_geojson_generator.html' %}
    {% include 'components/_map_editor.html' %}
    
    <div class="card mt-3">
        <div class="card-body">
            <form id="add-area-form" method="POST" novalidate>
                <div class="form-group">
                    <label for="type">Area Type</label>
                    <select class="form-control" id="type" name="type" required>
                        <option value="">Select Area Type</option>
                        {% for area_type in area_type_requirements.keys() %}
                        <option value="{{ area_type }}">{{ area_type|capitalize }}</option>
                        {% endfor %}
                    </select>
                    <div class="invalid-feedback">Please select an area type</div>
                </div>
                <table class="table table-striped mt-3" id="tags-table">
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Value</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Tags will be dynamically added here -->
                    </tbody>
                </table>
                <div class="mt-3 text-center">
                    <button type="button" id="add-optional-field-btn" class="btn btn-secondary">Add Optional Tag</button>
                    <button type="button" id="add-custom-field-btn" class="btn btn-secondary">Add Custom Tag</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Separate section for Add Area button -->
    <div class="mt-4 mb-5 text-center">
        <button id="submit-area-btn" class="btn btn-primary btn-lg">Add Area</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
<script src="{{ url_for('static', filename='js/utils.js') }}"></script>
<script src="{{ url_for('static', filename='js/validation.js') }}"></script>
<script src="{{ url_for('static', filename='js/map-editor.js') }}"></script>
<script src="{{ url_for('static', filename='js/osm-geojson-generator.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', async function() {
    
    window.areaTypeRequirements = {{ area_type_requirements | tojson | safe }};
    const areaTypeRequirements = window.areaTypeRequirements;
    const typeSelect = document.getElementById('type');
    const tagsTable = document.getElementById('tags-table').querySelector('tbody');
    const addOptionalFieldBtn = document.getElementById('add-optional-field-btn');
    const addCustomFieldBtn = document.getElementById('add-custom-field-btn');
    const form = document.getElementById('add-area-form');
    const submitAreaBtn = document.getElementById('submit-area-btn');
    
    // Template data from deleted area (if any)
    const templateArea = {{ template_area | tojson | safe if template_area else 'null' }};

    // Initialize map editor component
    const initialGeoJson = templateArea?.tags?.geo_json || null;
    const mapEditor = initMapEditor({
        containerId: 'map',
        initialGeoJson: initialGeoJson,
        onGeoJsonChange: (geometry) => { window.currentGeoJson = geometry; }
    });

    // Initialize OSM GeoJSON generator component
    initOsmGeojsonGenerator({
        mapEditor: mapEditor,
        onApply: (geometry) => mapEditor.updateGeoJson(geometry),
        onPopulationFound: (population, date) => {
            const popInput = tagsTable.querySelector('input[name="population"]');
            const popDateInput = tagsTable.querySelector('input[name="population:date"]');
            if (!popInput) return;
            
            const currentVal = popInput.value.trim();
            if (currentVal && !confirm(`Update population from ${currentVal} to ${population.toLocaleString()}?`)) {
                return;
            }
            
            popInput.value = population;
            if (popDateInput) popDateInput.value = date;
            showToast('Info', `Population (${population.toLocaleString()}) loaded from OpenStreetMap`, 'info');
        }
    });

    function getExistingKeys() {
        const keys = [];
        tagsTable.querySelectorAll('tr').forEach(row => {
            const keyElement = row.querySelector('td:first-child');
            if (!keyElement) return;
            const keyInput = keyElement.querySelector('input');
            const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();
            if (key) {
                keys.push(key);
            }
        });
        return keys;
    }

    function validateCustomKey(keyInput) {
        const key = keyInput.value.trim();
        const validation = validateKey(key, getExistingKeys());
        const feedback = keyInput.nextElementSibling;

        keyInput.classList.toggle('is-invalid', !validation.isValid);
        if (feedback && feedback.classList.contains('invalid-feedback')) {
            feedback.textContent = validation.message;
            feedback.style.display = validation.isValid ? 'none' : 'block';
        }

        if (!validation.isValid) {
            showToast('Error', validation.message, 'error');
        }

        return validation.isValid;
    }

    function createTagRow(key, value = '', isRequired = false, isCustom = false, allowedValues = null) {
        const row = document.createElement('tr');
        const isNumericField = key === 'population' || key === 'area_km2';
        
        row.innerHTML = `
            <td>
                ${isCustom ? 
                  `<input type="text" id="${key}" class="form-control custom-key" placeholder="Tag Name" required>
                     <div class="invalid-feedback">Please enter a valid key</div>` 
                    : key}
            </td>
            <td>
                ${allowedValues ? `
                    <select class="form-control" name="${key}" ${isRequired ? 'required' : ''}>
                        <option value="">Select ${key}</option>
                        ${allowedValues.map(val => `<option value="${val}">${val}</option>`).join('')}
                    </select>
                    <div class="invalid-feedback">Please select a value</div>
                ` : `
                    <input type="${isNumericField ? 'number' : 'text'}" 
                           class="form-control${isNumericField ? ' numeric-field' : ''}" 
                           name="${key}" 
                           value="${value}" 
                           ${isRequired ? 'required' : ''} 
                           ${isNumericField ? `min="0" step="${key === 'population' ? '1' : '0.01'}"` : ''}>
                    <div class="invalid-feedback">Please enter a valid value</div>
                `}
            </td>
            <td>
                ${!isRequired ? '<button type="button" class="btn btn-danger btn-sm remove-field">Remove</button>' : ''}
            </td>
        `;

        if (!isRequired) {
            row.querySelector('.remove-field').addEventListener('click', function() {
                row.remove();
            });
        }

        if (isCustom) {
            const keyInput = row.querySelector('.custom-key');
            
            keyInput.addEventListener('input', function() {
                this.classList.remove('is-invalid');
                const feedback = this.nextElementSibling;
                if (feedback && feedback.classList.contains('invalid-feedback')) {
                    feedback.style.display = 'none';
                }
            });
            keyInput.addEventListener('blur', function() {
                validateCustomKey(this);
            });

            // Add validation on focus out
            keyInput.addEventListener('focusout', function() {
                validateCustomKey(this);
            });
        }

        if (isNumericField) {
            const input = row.querySelector('input.numeric-field');
            input.addEventListener('input', function() {
                const validation = validateNumericValue(this.value, key === 'population' ? 'integer' : 'number');
                const feedback = this.nextElementSibling;
                
                if (!validation.isValid) {
                    this.classList.add('is-invalid');
                    if (feedback) {
                        feedback.textContent = validation.message;
                        feedback.style.display = 'block';
                    }
                    this.setCustomValidity(validation.message);
                } else {
                    this.classList.remove('is-invalid');
                    if (feedback) {
                        feedback.style.display = 'none';
                    }
                    this.setCustomValidity('');
                }
            });
        }

        return row;
    }

    function updateFields() {
        const selectedType = typeSelect.value;
        tagsTable.innerHTML = '';

        if (selectedType && areaTypeRequirements[selectedType]) {
            Object.entries(areaTypeRequirements[selectedType])
                .filter(([key, requirements]) => requirements.required && key !== 'icon:square')
                .forEach(([key, requirements]) => {
                    tagsTable.appendChild(createTagRow(
                        key, 
                        '', 
                        true, 
                        false, 
                        requirements.allowed_values
                    ));
                });
        }
    }

    function addOptionalField() {
        const selectedType = typeSelect.value;
        
        if (!selectedType) {
            showToast('Error', 'Please select an area type first', 'error');
            return;
        }

        const existingKeys = getExistingKeys();
        const optionalFields = Object.entries(areaTypeRequirements[selectedType] || {})
            .filter(([key, req]) => !req.required && !existingKeys.includes(key))
            .map(([key]) => key);

        if (optionalFields.length === 0) {
            showToast('Info', 'All optional fields have been added', 'info');
            return;
        }

        const newRow = document.createElement('tr');
        newRow.innerHTML = `
            <td>
                <select class="form-control optional-field-select" required>
                    <option value="">Select Tag</option>
                    ${optionalFields.map(field => `<option value="${field}">${field}</option>`).join('')}
                </select>
                <div class="invalid-feedback">Please select a field</div>
            </td>
            <td>
                <input type="text" class="form-control" disabled>
                <div class="invalid-feedback">Please enter a valid value</div>
            </td>
            <td>
                <button type="button" class="btn btn-danger btn-sm remove-field">Remove</button>
            </td>
        `;

        const optionalFieldSelect = newRow.querySelector('.optional-field-select');
        optionalFieldSelect.addEventListener('change', function() {
            const selectedField = this.value;
            if (!selectedField) return;

            const requirements = areaTypeRequirements[selectedType][selectedField];
            const row = createTagRow(
                selectedField,
                '',
                false,
                false,
                requirements.allowed_values
            );
            tagsTable.replaceChild(row, newRow);
        });

        newRow.querySelector('.remove-field').addEventListener('click', function() {
            newRow.remove();
        });

        tagsTable.appendChild(newRow);
    }

    function addCustomField() {
        const newRow = createTagRow('', '', false, true);
        tagsTable.appendChild(newRow);
    }
  
    async function parseIssueData(issueText){
        const issueData = {}
        const issueTemplate = {
              "Community name: ": "communityName",
              "Location: ": "location",
              "Associated areas: ": "associatedAreas",
              "GeoJSON: ": "geoJSON",
              "Icon URL: ": "icon",
              "Lightning: ": "lightningTips",
              "Social links: ": "contact",
              "Community leader contact: ": "leaderContact",
              "Notes: ": "description"
        }
        
        const keys = Object.keys(issueTemplate)
        
        for (let i = 0; i < keys.length; i++) {
            const startKey = keys[i]
            const endKey = keys[i + 1] || "Created at: "
            const fieldName = issueTemplate[startKey]
             
            const startIdx = issueText.indexOf(startKey)
            if (startIdx === -1) {
                console.warn(`Issue template missing field: ${startKey}`)
                issueData[fieldName] = ""
                continue
            }
              
            const endIdx = issueText.indexOf(endKey, startIdx + startKey.length)
            if (endIdx === -1) {
                issueData[fieldName] = issueText.substring(startIdx + startKey.length).trim()
            } else {
                issueData[fieldName] = issueText.substring(startIdx + startKey.length, endIdx).trim()
            }
        }
          
        return issueData
    }

    async function fetchIssueData(issueId){
        try {
            let response = await apiFetch(`/api/gitea/get-issue/${issueId}`)
            let result = await response.json()
            
            if (!response.ok || result.error) {
                throw new Error(result.error || 'Failed to fetch issue data')
            }
            
            return result.data
        } catch (error) {
            if (error.message === 'Session expired') throw error;
            showToast('Error', `Failed to load issue #${issueId}: ${error.message}`, 'error')
            throw error
        }
    }

    async function fillContact(issueData){ 
        let contactRaw = issueData.contact.split("\n");
        let contact = []
        for(let i=0;i<contactRaw.length;i++){
          if(contactRaw[i].length > 10){
            contact.push(contactRaw[i])
          }
        }
        return contact
    }

    async function fillContactFields(contact){
      const contactTagsInfo = [
          {name:"contact:email", index: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/},
          {name:"contact:discord", index: /discord\.gg|discord\.com/i},
          {name:"contact:twitter", index: /(?:x\.com|twitter\.com)\/[\w]+/i},
          {name:"contact:telegram", index: /t\.me\/[\w]+/i},
          {name:"contact:signal", index: /signal\.group\//i},
          {name:"contact:whatsapp", index: /chat\.whatsapp\.com\//i},
          {name:"contact:facebook", index: /facebook\.com\/[\w.]+/i},
          {name:"contact:instagram", index: /instagram\.com\/[\w._]+/i},
          {name:"contact:youtube", index: /(?:youtu\.be|youtube\.com)\//i},
          {name:"contact:github", index: /github\.com\/[\w-]+/i},
          {name:"contact:linkedin", index: /linkedin\.com\//i},
          {name:"contact:matrix", index: /@[\w._-]+:[\w.-]+/},
          {name:"contact:meetup", index: /meetup\.com\//i},
          {name:"contact:nostr", index: /^npub1[a-z0-9]{58}$/},
          {name:"contact:geyser", index: /geyser\.fund\//i},
          {name:"contact:rss", index: /\/(?:feed|rss)/i},
          {name:"contact:phone", index: /^\+?[\d\s\-()]+$/},
          {name:"contact:website", index: /^https?:\/\//i}
      ]
        for(let i=0;i<contact.length;i++){
          for(let j=0;j<contactTagsInfo.length;j++){
            if(contactTagsInfo[j].index.test(contact[i])){
              let newRow = createTagRow(contactTagsInfo[j].name, contact[i], false, false);
              tagsTable.appendChild(newRow);
              break
            }
          } 
        }
    }
    
    async function fillFields(issueData){
      const MIN_FIELD_LENGTH = 10;
      let contact = await fillContact(issueData)
      function cleanIssueText(text) {
          return text?.replace(/\n/g, ' ').trim() || ''
      }

      let prefilledCommunityData = {
          "name": cleanIssueText(issueData.communityName),
          "icon": cleanIssueText(issueData.icon),
          "lightningTips": cleanIssueText(issueData.lightningTips),
          "contact": contact,
          "description": cleanIssueText(issueData.description)
      }
      tagsTable.querySelector('input[name="name"]').value = prefilledCommunityData.name
      document.getElementById("sugestions").textContent = `suggested logo: ${prefilledCommunityData.icon}`
      let urlAlias = prefilledCommunityData.name.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-zA-Z0-9\s]/g, "").toLowerCase().trim().replace(/\s+/g, "-");
      tagsTable.querySelector('input[name="url_alias"]').value = urlAlias


      let newRow
      if(prefilledCommunityData?.lightningTips.length > MIN_FIELD_LENGTH){
          newRow = createTagRow('tips:lightning_address', prefilledCommunityData.lightningTips, false, false);
          tagsTable.appendChild(newRow);
      }
      if(prefilledCommunityData?.description.length > MIN_FIELD_LENGTH){
          newRow = createTagRow('description', prefilledCommunityData.description, false, false);
          tagsTable.appendChild(newRow);
      }
      await fillContactFields(contact)
    }

    async function fillFieldsPassingIssue(issueId){
        let issueReqData = await fetchIssueData(issueId) 
        let issueData = await parseIssueData(issueReqData.body)
        await fillFields(issueData)
    }

    window.validateAreaForm = function() {
        let isValid = true;
        let errorMessages = [];

        // Reset all validation states
        form.querySelectorAll('.is-invalid').forEach(element => {
            element.classList.remove('is-invalid');
        });

        // Validate area type
        if (!typeSelect.value) {
            isValid = false;
            errorMessages.push('Please select an area type');
            typeSelect.classList.add('is-invalid');
        }

        // Validate all fields
        tagsTable.querySelectorAll('tr').forEach(row => {
            const keyElement = row.querySelector('td:first-child');
            const keyInput = keyElement.querySelector('input');
            const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();
            
            // Validate key if it's a custom field
            if (keyInput) {
                if (!validateCustomKey(keyInput)) {
                    isValid = false;
                }
            }

            const valueInput = row.querySelector('td:nth-child(2) input, td:nth-child(2) select');
            if (!valueInput) {
                isValid = false;
                errorMessages.push(`No input field found for ${key}`);
                return;
            }

            const value = valueInput.value.trim();
            const requirements = areaTypeRequirements[typeSelect.value]?.[key] || { type: 'text', required: false };

            // Check if the field is required
            if (requirements.required && !value) {
                isValid = false;
                errorMessages.push(`${key} is required`);
                valueInput.classList.add('is-invalid');
                return;
            }

            // Validate value if present
            if (value) {
                const validation = validateValue(value, { ...requirements, key });
                if (!validation.isValid) {
                    isValid = false;
                    errorMessages.push(`${key}: ${validation.message}`);
                    valueInput.classList.add('is-invalid');
                }
            }
        });

        if (!isValid && errorMessages.length > 0) {
            showToast('Error', errorMessages.join('\n'), 'error');
        }

        return isValid;
    }

    window.addEventListener('unhandledrejection', function(event) {
        console.error('Unhandled rejection:', event.reason);
        showToast('Error', event.reason?.message || 'An unexpected error occurred', 'error');
    });

    // Initialize the form
    typeSelect.addEventListener('change', updateFields);
    addOptionalFieldBtn.addEventListener('click', addOptionalField);
    addCustomFieldBtn.addEventListener('click', addCustomField);
    
    // If we have template data, pre-fill the form
    if (templateArea && templateArea.tags) {
        const templateTags = templateArea.tags;
        
        // Set the area type first
        if (templateTags.type) {
            typeSelect.value = templateTags.type;
            updateFields();
            
            // Now fill in the values
            setTimeout(() => {
                // Fill required fields
                tagsTable.querySelectorAll('tr').forEach(row => {
                    const keyElement = row.querySelector('td:first-child');
                    const key = keyElement.textContent.trim();
                    const valueInput = row.querySelector('td:nth-child(2) input, td:nth-child(2) select');
                    
                    if (valueInput && templateTags[key] !== undefined && key !== 'icon:square') {
                        valueInput.value = templateTags[key];
                    }
                });
                
                // Add optional fields that have values in the template
                const existingKeys = getExistingKeys();
                Object.entries(templateTags).forEach(([key, value]) => {
                    if (key === 'type' || key === 'geo_json' || key === 'icon:square' || existingKeys.includes(key)) {
                        return;
                    }
                    
                    // Check if it's an optional field for this type
                    const requirements = areaTypeRequirements[templateTags.type]?.[key];
                    if (requirements && !requirements.required) {
                        const row = createTagRow(key, value, false, false, requirements.allowed_values);
                        tagsTable.appendChild(row);
                        // Set the value after adding (for selects)
                        const valueInput = row.querySelector('td:nth-child(2) input, td:nth-child(2) select');
                        if (valueInput) {
                            valueInput.value = value;
                        }
                    } else if (!requirements) {
                        // It's a custom field
                        const row = createTagRow(key, value, false, false);
                        tagsTable.appendChild(row);
                    }
                });
                
                // GeoJSON is already loaded via mapEditor initialization
            }, 100);
        }
    } else {
        // Default to 'community' type
        typeSelect.value = 'community';
        updateFields();
    }
  
    const issueId = getURLParameter("issue-id")
    if(issueId){
       await fillFieldsPassingIssue(issueId) 
    }
});

// ============================================
// Icon Editor Functionality
// ============================================

const ICON_MIN_SIZE = 128;
const ICON_MAX_SIZE = 1024;
const ICON_OUTPUT_SIZE = 256;

let iconCropper = null;
let iconCurrentFile = null;
let pendingIconBase64 = null;

const iconElements = {
    fileInput: null,
    cropperContainer: null,
    cropperImage: null,
    previewContainer: null,
    iconPreview: null,
    iconPreviewLarge: null,
    dimensionInfo: null,
    dimensionText: null,
    iconError: null,
    confirmIconBtn: null,
    removeIconBtn: null,
    modal: null,
    iconPlaceholder: null,
    iconPlaceholderText: null,
    iconPreviewDisplay: null,
    urlInput: null,
    loadUrlBtn: null
};

function initializeIconEditor() {
    iconElements.fileInput = document.getElementById('iconFileInput');
    iconElements.cropperContainer = document.getElementById('cropperContainer');
    iconElements.cropperImage = document.getElementById('cropperImage');
    iconElements.previewContainer = document.getElementById('previewContainer');
    iconElements.iconPreview = document.getElementById('iconPreview');
    iconElements.iconPreviewLarge = document.getElementById('iconPreviewLarge');
    iconElements.dimensionInfo = document.getElementById('dimensionInfo');
    iconElements.dimensionText = document.getElementById('dimensionText');
    iconElements.iconError = document.getElementById('iconError');
    iconElements.confirmIconBtn = document.getElementById('confirmIconBtn');
    iconElements.removeIconBtn = document.getElementById('removeIconBtn');
    iconElements.modal = document.getElementById('editIconModal');
    iconElements.iconPlaceholder = document.getElementById('icon-placeholder');
    iconElements.iconPlaceholderText = document.getElementById('icon-placeholder-text');
    iconElements.iconPreviewDisplay = document.getElementById('icon-preview-display');
    iconElements.urlInput = document.getElementById('iconUrlInput');
    iconElements.loadUrlBtn = document.getElementById('loadIconUrlBtn');

    if (!iconElements.fileInput) return;

    iconElements.fileInput.addEventListener('change', handleIconFileSelect);
    iconElements.confirmIconBtn.addEventListener('click', confirmIcon);
    iconElements.removeIconBtn.addEventListener('click', removeIcon);
    iconElements.loadUrlBtn.addEventListener('click', () => loadIconFromUrl(iconElements.urlInput.value));

    // Reset cropper state when modal is closed (but keep pending icon)
    iconElements.modal.addEventListener('hidden.bs.modal', resetCropperState);
}

function resetCropperState() {
    if (iconCropper) {
        iconCropper.destroy();
        iconCropper = null;
    }
    iconCurrentFile = null;
    iconElements.fileInput.value = '';
    if (iconElements.urlInput) {
        iconElements.urlInput.value = '';
    }
    iconElements.cropperContainer.style.display = 'none';
    iconElements.previewContainer.style.display = 'none';
    iconElements.dimensionInfo.style.display = 'none';
    iconElements.iconError.style.display = 'none';
    iconElements.confirmIconBtn.disabled = true;
}

function resetIconEditor() {
    resetCropperState();
    pendingIconBase64 = null;
    iconElements.iconPreviewDisplay.style.display = 'none';
    iconElements.iconPlaceholderText.style.display = 'block';
    iconElements.removeIconBtn.style.display = 'none';
}

function showIconError(message) {
    iconElements.iconError.textContent = message;
    iconElements.iconError.style.display = 'block';
    iconElements.confirmIconBtn.disabled = true;
}

function hideIconError() {
    iconElements.iconError.style.display = 'none';
}

function handleIconFileSelect(e) {
    const file = e.target.files[0];
    if (!file) return;

    hideIconError();

    const validTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/svg+xml'];
    if (!validTypes.includes(file.type)) {
        showIconError('Invalid file type. Please upload a PNG, JPG, WebP, or SVG image.');
        return;
    }

    iconCurrentFile = file;

    const reader = new FileReader();
    reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
            if (img.width < ICON_MIN_SIZE || img.height < ICON_MIN_SIZE) {
                showIconError(`Image is too small. Minimum size is ${ICON_MIN_SIZE}x${ICON_MIN_SIZE} pixels. Your image is ${img.width}x${img.height} pixels.`);
                return;
            }

            if (img.width > 4096 || img.height > 4096) {
                showIconError(`Image is too large. Maximum size is 4096x4096 pixels. Your image is ${img.width}x${img.height} pixels.`);
                return;
            }

            iconElements.dimensionText.textContent = `Original size: ${img.width} x ${img.height} pixels`;
            iconElements.dimensionInfo.style.display = 'block';

            initializeIconCropper(event.target.result);
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

async function loadIconFromUrl(url) {
    if (!url) {
        showIconError('Please enter a valid URL');
        return;
    }

    hideIconError();
    iconElements.loadUrlBtn.disabled = true;
    iconElements.loadUrlBtn.textContent = 'Loading...';

    try {
        // Use a proxy endpoint to fetch the image (avoids CORS issues)
        const response = await apiFetch('/api/proxy_image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: url })
        });

        if (!response.ok) {
            const data = await response.json();
            throw new Error(data.error || 'Failed to load image');
        }

        const data = await response.json();
        const imageSrc = `data:${data.content_type};base64,${data.image_base64}`;

        // Create an image to check dimensions
        const img = new Image();
        img.onload = function() {
            // Check minimum dimensions
            if (img.width < ICON_MIN_SIZE || img.height < ICON_MIN_SIZE) {
                showIconError(`Image is too small. Minimum size is ${ICON_MIN_SIZE}x${ICON_MIN_SIZE} pixels. The image is ${img.width}x${img.height} pixels.`);
                return;
            }

            // Check maximum dimensions
            if (img.width > 4096 || img.height > 4096) {
                showIconError(`Image is too large. Maximum size is 4096x4096 pixels. The image is ${img.width}x${img.height} pixels.`);
                return;
            }

            // Show dimension info
            iconElements.dimensionText.textContent = `Original size: ${img.width} x ${img.height} pixels`;
            iconElements.dimensionInfo.style.display = 'block';

            // Set a dummy file for reference
            iconCurrentFile = { type: 'image/png' };

            // Initialize cropper
            initializeIconCropper(imageSrc);
        };
        img.onerror = function() {
            showIconError('Failed to load image from the provided data');
        };
        img.src = imageSrc;

    } catch (error) {
        if (error.message === 'Session expired') return;
        console.error('Error loading image from URL:', error);
        showIconError(error.message || 'Failed to load image from URL');
    } finally {
        iconElements.loadUrlBtn.disabled = false;
        iconElements.loadUrlBtn.textContent = 'Load';
    }
}

function initializeIconCropper(imageSrc) {
    if (iconCropper) {
        iconCropper.destroy();
    }

    iconElements.cropperImage.src = imageSrc;
    iconElements.cropperContainer.style.display = 'block';

    iconCropper = new Cropper(iconElements.cropperImage, {
        aspectRatio: 1,
        viewMode: 1,
        dragMode: 'move',
        autoCropArea: 1,
        restore: false,
        guides: true,
        center: true,
        highlight: false,
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
        minCropBoxWidth: ICON_MIN_SIZE,
        minCropBoxHeight: ICON_MIN_SIZE,
        ready: function() {
            updateIconPreview();
            iconElements.confirmIconBtn.disabled = false;
        },
        crop: function() {
            updateIconPreview();
        }
    });
}

function updateIconPreview() {
    if (!iconCropper) return;

    const canvas = iconCropper.getCroppedCanvas({
        width: ICON_OUTPUT_SIZE,
        height: ICON_OUTPUT_SIZE,
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high'
    });

    if (canvas) {
        const dataUrl = canvas.toDataURL('image/png');
        iconElements.iconPreview.src = dataUrl;
        iconElements.iconPreviewLarge.src = dataUrl;
        iconElements.previewContainer.style.display = 'block';
    }
}

function confirmIcon() {
    if (!iconCropper) {
        showIconError('No image selected');
        return;
    }

    hideIconError();

    try {
        const canvas = iconCropper.getCroppedCanvas({
            width: ICON_OUTPUT_SIZE,
            height: ICON_OUTPUT_SIZE,
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high'
        });

        if (!canvas) {
            throw new Error('Failed to crop image');
        }

        if (canvas.width < ICON_MIN_SIZE || canvas.height < ICON_MIN_SIZE) {
            throw new Error(`Cropped area is too small. Please select a larger area (minimum ${ICON_MIN_SIZE}x${ICON_MIN_SIZE} pixels).`);
        }

        // Get base64 data
        const dataUrl = canvas.toDataURL('image/png');
        pendingIconBase64 = dataUrl.split(',')[1];

        // Update the placeholder to show the selected image
        iconElements.iconPreviewDisplay.src = dataUrl;
        iconElements.iconPreviewDisplay.style.display = 'block';
        iconElements.iconPlaceholderText.style.display = 'none';
        iconElements.removeIconBtn.style.display = 'inline-block';

        // Close modal
        const modal = bootstrap.Modal.getOrCreateInstance(iconElements.modal);
        modal.hide();

        showToast('Success', 'Icon selected. It will be uploaded when you add the area.', 'success');

    } catch (error) {
        console.error('Error confirming icon:', error);
        showIconError(error.message || 'Failed to process icon');
    }
}

function removeIcon() {
    pendingIconBase64 = null;
    iconElements.iconPreviewDisplay.style.display = 'none';
    iconElements.iconPlaceholderText.style.display = 'block';
    iconElements.removeIconBtn.style.display = 'none';
    
    const modal = bootstrap.Modal.getOrCreateInstance(iconElements.modal);
    modal.hide();

    showToast('Info', 'Icon removed', 'info');
}

async function uploadIcon(areaId) {
    if (!pendingIconBase64) {
        return { success: true };
    }

    try {
        const response = await apiFetch('/api/set_area_icon', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: areaId,
                icon_base64: pendingIconBase64,
                icon_ext: 'png'
            })
        });

        const data = await response.json();

        if (!response.ok || data.error) {
            throw new Error(data.error || 'Failed to upload icon');
        }

        return { success: true };
    } catch (error) {
        if (error.message === 'Session expired') {
            return { success: false, error: 'Session expired' };
        }
        console.error('Error uploading icon:', error);
        return { success: false, error: error.message };
    }
}



// Initialize icon editor when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeIconEditor();
    
    // Set up submit handler for area creation with icon upload
    const submitAreaBtn = document.getElementById('submit-area-btn');
    if (!submitAreaBtn) return;
    
    submitAreaBtn.addEventListener('click', async function(e) {
        e.preventDefault();

        // Use the validation function from the main form handler
        if (window.validateAreaForm && !window.validateAreaForm()) {
            return;
        }

        const typeSelect = document.getElementById('type');
        const tagsTable = document.getElementById('tags-table').querySelector('tbody');

        // Get areaTypeRequirements from the page
        const areaTypeRequirements = window.areaTypeRequirements || {};

        const tags = {};

        // Collect all valid tags
        tagsTable.querySelectorAll('tr').forEach(row => {
            const keyElement = row.querySelector('td:first-child');
            const keyInput = keyElement.querySelector('input');
            const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();

            const valueInput = row.querySelector('td:nth-child(2) input, td:nth-child(2) select');
            if (valueInput && valueInput.value.trim()) {
                let value = valueInput.value.trim();
                const requirements = areaTypeRequirements[typeSelect.value]?.[key] || { type: 'text' };

                if (requirements.type === 'number' || requirements.type === 'integer') {
                    const numVal = requirements.type === 'integer' ? parseInt(value, 10) : parseFloat(value);
                    if (!isNaN(numVal)) {
                        value = numVal;
                    }
                }
                tags[key] = value;
            }
        });

        // Add type and GeoJSON
        tags['type'] = typeSelect.value;
        if (window.currentGeoJson) {
            tags['geo_json'] = window.currentGeoJson;
        }

        // Set verified:date to current date (YYYY-MM-DD format)
        const today = new Date();
        const verifiedDate = today.toISOString().split('T')[0];
        tags['verified:date'] = verifiedDate;

        // If we have a pending icon, provide a placeholder for icon:square
        if (pendingIconBase64 && !tags['icon:square']) {
            tags['icon:square'] = 'pending-upload';
        }

        submitAreaBtn.disabled = true;
        submitAreaBtn.textContent = 'Creating Area...';

        try {
            const response = await apiFetch('/add_area', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(Object.fromEntries(
                    Object.entries(tags).map(([key, value]) => {
                        if (key === 'geo_json' && typeof value === 'object') {
                            return [key, value];
                        } else if (typeof value === 'number') {
                            return [key, value];
                        } else {
                            return [key, String(value)];
                        }
                    })
                ))
            });

            const data = await response.json();

            if (!response.ok || data.error) {
                throw new Error(data.error?.message || data.error || 'Failed to add area');
            }

            const areaId = data.area_id;

            // Upload the icon if we have one
            if (pendingIconBase64 && areaId) {
                submitAreaBtn.textContent = 'Uploading Icon...';
                
                const iconResult = await uploadIcon(areaId);
                
                if (!iconResult.success) {
                    showToast('Warning', `Area created but icon upload failed: ${iconResult.error}. You can update the icon later.`, 'warning');
                    setTimeout(() => {
                        window.location.href = `/show_area/${areaId}`;
                    }, 3000);
                    return;
                }
            }

            showToast('Success', 'Area added successfully', 'success');
            setTimeout(() => {
                if (areaId) {
                    window.location.href = `/show_area/${areaId}`;
                } else {
                    window.location.href = '/select_area';
                }
            }, 2000);

        } catch (error) {
            if (error.message === 'Session expired') return;
            console.error('Error adding area:', error);
            showToast('Error', error.message || 'An unexpected error occurred', 'error');
        } finally {
            submitAreaBtn.disabled = false;
            submitAreaBtn.textContent = 'Add Area';
        }
    });
});
</script>
{% endblock %}
