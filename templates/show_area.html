{% extends "base.html" %}

{% block title %}Show Area{% endblock %}

{% block content %}
<div class="container">
    <h1>Area Details</h1>
    <h2>{{ area.tags.get('name', 'Unnamed Area') }} ({{ area.tags.get('type', 'Unknown Type') }})</h2>

    <!-- Map container -->
    <div id="map-container">
        <div id="map"></div>
        <button id="edit-geojson-btn" class="btn btn-primary">Edit GeoJSON</button>
    </div>

    <!-- GeoJSON editor -->
    <div id="geojson-editor" class="mb-3" style="display: none;">
        <textarea id="geojson-input" class="form-control mb-2" rows="5"></textarea>
        <div class="btn-group">
            <button id="show-btn" class="btn btn-primary">Show</button>
            <button id="update-btn" class="btn btn-success">Update</button>
            <button id="cancel-btn" class="btn btn-secondary">Cancel</button>
        </div>
    </div>

    <!-- Area information -->
    <div class="card mt-4 mb-4">
        <div class="card-body">
            <table id="tags-table" class="table table-striped">
                <thead>
                    <tr>
                        <th>Key</th>
                        <th>Value</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for key, requirements in area_type_requirements.items() %}
                    <tr data-key="{{ key }}">
                        <td>{{ key }}</td>
                        <td class="tag-value-cell">
                            <span class="tag-value-content">{{ area.tags.get(key, '') }}</span>
                            {% if requirements.get('allowed_values') %}
                            <select class="form-control tag-select d-none">
                                {% for value in requirements.allowed_values %}
                                <option value="{{ value }}" {% if value == area.tags.get(key) %}selected{% endif %}>{{ value }}</option>
                                {% endfor %}
                            </select>
                            {% else %}
                            <input type="text" class="form-control tag-input d-none" value="{{ area.tags.get(key, '') }}">
                            {% endif %}
                            <div class="invalid-feedback"></div>
                        </td>
                        <td>
                            <button class="btn btn-primary btn-sm edit-tag">Edit</button>
                            <button class="btn btn-success btn-sm update-tag d-none">Update</button>
                            <button class="btn btn-secondary btn-sm cancel-edit d-none">Cancel</button>
                            {% if not requirements.get('required', False) %}
                            <button class="btn btn-danger btn-sm delete-tag">Remove</button>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            <div class="mt-3 text-center">
                <button type="button" id="add-optional-field-btn" class="btn btn-secondary">Add Optional Field</button>
                <button type="button" id="add-custom-field-btn" class="btn btn-secondary">Add Custom Field</button>
            </div>
        </div>
    </div>

    <!-- Danger Zone -->
    <div class="mt-4 mb-4">
        <div class="card border-danger">
            <div class="card-header bg-danger text-white text-center">
                <h3 class="mb-0">Danger Zone</h3>
            </div>
            <div class="card-body text-center">
                <p class="text-danger mb-3">Warning: This action cannot be undone!</p>
                <button class="btn btn-danger btn-lg" onclick="removeArea('{{ area.id }}')">Remove Area</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="{{ url_for('static', filename='js/validation.js') }}"></script>
<script>
// Global variables
let map;
let geoJsonLayer;
let mapInitialized = false;
const elements = {
    mapContainer: document.getElementById('map'),
    editGeoJsonBtn: document.getElementById('edit-geojson-btn'),
    geoJsonEditor: document.getElementById('geojson-editor'),
    geoJsonInput: document.getElementById('geojson-input'),
    showBtn: document.getElementById('show-btn'),
    updateBtn: document.getElementById('update-btn'),
    cancelBtn: document.getElementById('cancel-btn'),
    tagsTable: document.getElementById('tags-table'),
    addOptionalFieldBtn: document.getElementById('add-optional-field-btn'),
    addCustomFieldBtn: document.getElementById('add-custom-field-btn')
};

// Debug logging function
function logDebug(message, error = null) {
    console.log(`[Debug] ${message}`);
    if (error) {
        console.error('[Error]', error);
    }
}

// Map initialization
function initializeMap() {
    try {
        logDebug('Initializing map...');
        if (!elements.mapContainer) {
            throw new Error('Map container not found');
        }

        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        const geoJson = {{ geo_json | tojson | safe if geo_json else 'null' }};
        if (geoJson) {
            updateMapWithGeoJson(geoJson);
        }

        mapInitialized = true;
        logDebug('Map initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize map', error);
        showToast('Error', 'Failed to initialize map: ' + error.message, 'error');
    }
}

// Update map with GeoJSON
function updateMapWithGeoJson(geoJson) {
    try {
        logDebug('Updating map with GeoJSON input:', geoJson);

        if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
        }

        if (typeof geoJson === 'string') {
            geoJson = JSON.parse(geoJson);
        }

        logDebug('Adding GeoJSON to map:', geoJson);
        geoJsonLayer = L.geoJSON(geoJson).addTo(map);
        map.fitBounds(geoJsonLayer.getBounds());
        logDebug('GeoJSON updated successfully');
        return true;
    } catch (error) {
        logDebug('Failed to update GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
        return false;
    }
}

// Initialize event listeners
function initializeEventListeners() {
    try {
        logDebug('Initializing event listeners');

        // GeoJSON editor buttons
        if (elements.editGeoJsonBtn) {
            elements.editGeoJsonBtn.addEventListener('click', startGeoJsonEditing);
        }
        if (elements.showBtn) {
            elements.showBtn.addEventListener('click', showGeoJson);
        }
        if (elements.updateBtn) {
            elements.updateBtn.addEventListener('click', updateGeoJson);
        }
        if (elements.cancelBtn) {
            elements.cancelBtn.addEventListener('click', cancelGeoJsonEditing);
        }

        // Tags management buttons
        if (elements.addOptionalFieldBtn) {
            elements.addOptionalFieldBtn.addEventListener('click', addOptionalField);
        }
        if (elements.addCustomFieldBtn) {
            elements.addCustomFieldBtn.addEventListener('click', addCustomField);
        }

        // Tags table event delegation
        if (elements.tagsTable) {
            elements.tagsTable.addEventListener('click', handleTagsTableClick);
        }

        logDebug('Event listeners initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize event listeners', error);
        showToast('Error', 'Failed to initialize event listeners: ' + error.message, 'error');
    }
}

// GeoJSON editing functions
function startGeoJsonEditing() {
    logDebug('Starting GeoJSON editing');
    elements.geoJsonEditor.style.display = 'block';
    const geoJson = geoJsonLayer.toGeoJSON();
    const geometry = geoJson.type === 'FeatureCollection'
        ? geoJson.features[0].geometry
        : geoJson.type === 'Feature'
            ? geoJson.geometry
            : geoJson;
    elements.geoJsonInput.value = JSON.stringify(geometry, null, 2);
}

function showGeoJson() {
    try {
        const geoJson = JSON.parse(elements.geoJsonInput.value);
        if (updateMapWithGeoJson(geoJson)) {
            showToast('Success', 'GeoJSON preview updated', 'success');
        }
    } catch (error) {
        logDebug('Failed to show GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function updateGeoJson() {
    try {
        logDebug('Starting GeoJSON update');
        const rawInput = elements.geoJsonInput.value;
        const geoJson = JSON.parse(rawInput);

        logDebug('Clean GeoJSON:', geoJson);

        fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: "{{ area.id }}",
                name: 'geo_json',
                value: geoJson
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `HTTP error! status: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                throw new Error(data.error || 'Failed to update GeoJSON');
            }
            logDebug('GeoJSON successfully updated on server');
            showToast('Success', 'GeoJSON updated successfully', 'success');
            elements.geoJsonEditor.style.display = 'none';
            updateMapWithGeoJson(geoJson);
        })
        .catch(error => {
            logDebug('Failed to update GeoJSON on server', error);
            showToast('Error', error.message || 'Failed to update GeoJSON', 'error');
        });
    } catch (error) {
        logDebug('Failed to process GeoJSON input', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function cancelGeoJsonEditing() {
    elements.geoJsonEditor.style.display = 'none';
}

// Tag management functions
function getExistingKeys() {
    const keys = [];
    elements.tagsTable.querySelectorAll('tbody tr').forEach(row => {
        const keyElement = row.querySelector('td:first-child');
        const keyInput = keyElement.querySelector('input');
        const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();
        if (key) {
            keys.push(key);
        }
    });
    return keys;
}

function validateCustomKey(keyInput) {
    const key = keyInput.value.trim();
    const validation = validateKey(key, getExistingKeys());
    const feedback = keyInput.nextElementSibling;

    keyInput.classList.toggle('is-invalid', !validation.isValid);
    if (feedback && feedback.classList.contains('invalid-feedback')) {
        feedback.textContent = validation.message;
        feedback.style.display = validation.isValid ? 'none' : 'block';
    }

    if (!validation.isValid) {
        showToast('Error', validation.message, 'error');
    }

    return validation.isValid;
}

function createTagRow(key, value = '', isRequired = false, isCustom = false, allowedValues = null) {
    const row = document.createElement('tr');
    const isNumericField = key === 'population' || key === 'area_km2';

    row.innerHTML = `
        <td>
            ${isCustom ? 
                `<input type="text" class="form-control custom-key" placeholder="Custom Key" required>
                 <div class="invalid-feedback">Please enter a valid key</div>` 
                : key}
        </td>
        <td class="tag-value-cell">
            ${allowedValues ? `
                <select class="form-control" name="${key}" ${isRequired ? 'required' : ''}>
                    <option value="">Select ${key}</option>
                    ${allowedValues.map(val => `<option value="${val}">${val}</option>`).join('')}
                </select>
                <div class="invalid-feedback">Please select a value</div>
            ` : `
                <input type="${isNumericField ? 'number' : 'text'}" 
                       class="form-control${isNumericField ? ' numeric-field' : ''}" 
                       name="${key}" 
                       value="${value}" 
                       ${isRequired ? 'required' : ''} 
                       ${isNumericField ? `min="0" step="${key === 'population' ? '1' : '0.01'}"` : ''}>
                <div class="invalid-feedback">Please enter a valid value</div>
            `}
        </td>
        <td>
            <button class="btn btn-success btn-sm update-tag">Update</button>
            <button class="btn btn-danger btn-sm remove-field">Remove</button>
        </td>
    `;

    // Add event listeners
    if (!isRequired) {
        row.querySelector('.remove-field').addEventListener('click', function() {
            row.remove();
            updateOptionalFieldSelect();
        });
    }

    if (isCustom) {
        const keyInput = row.querySelector('.custom-key');
        keyInput.addEventListener('input', function() {
            this.classList.remove('is-invalid');
            const feedback = this.nextElementSibling;
            if (feedback && feedback.classList.contains('invalid-feedback')) {
                feedback.style.display = 'none';
            }
        });
        keyInput.addEventListener('blur', function() {
            validateCustomKey(this);
        });
    }

    if (isNumericField) {
        const input = row.querySelector('input.numeric-field');
        input.addEventListener('input', function() {
            const validation = validateNumericValue(this.value, key === 'population' ? 'integer' : 'number');
            const feedback = this.nextElementSibling;

            if (!validation.isValid) {
                this.classList.add('is-invalid');
                if (feedback) {
                    feedback.textContent = validation.message;
                    feedback.style.display = 'block';
                }
                this.setCustomValidity(validation.message);
            } else {
                this.classList.remove('is-invalid');
                if (feedback) {
                    feedback.style.display = 'none';
                }
                this.setCustomValidity('');
            }
        });
    }

    return row;
}

function addOptionalField() {
    const areaType = '{{ area.tags.get("type", "") }}';
    if (!areaType) {
        showToast('Error', 'Area type not found', 'error');
        return;
    }

    const existingKeys = getExistingKeys();
    const areaTypeReqs = {{ area_type_requirements | tojson | safe }};
    const optionalFields = Object.entries(areaTypeReqs[areaType] || {})
        .filter(([key, req]) => !req.required && !existingKeys.includes(key))
        .map(([key]) => key);

    if (optionalFields.length === 0) {
        showToast('Info', 'All optional fields have been added', 'info');
        return;
    }

    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td>
            <select class="form-control optional-field-select" required>
                <option value="">Select Optional Field</option>
                ${optionalFields.map(field => `<option value="${field}">${field}</option>`).join('')}
            </select>
            <div class="invalid-feedback">Please select a field</div>
        </td>
        <td>
            <input type="text" class="form-control" disabled>
            <div class="invalid-feedback">Please enter a valid value</div>
        </td>
        <td>
            <button type="button" class="btn btn-danger btn-sm remove-field">Remove</button>
        </td>
    `;

    const optionalFieldSelect = newRow.querySelector('.optional-field-select');
    optionalFieldSelect.addEventListener('change', function() {
        const selectedField = this.value;
        if (!selectedField) return;

        const requirements = areaTypeReqs[areaType][selectedField];
        const row = createTagRow(
            selectedField,
            '',
            false,
            false,
            requirements.allowed_values
        );
        elements.tagsTable.querySelector('tbody').replaceChild(row, newRow);
    });

    newRow.querySelector('.remove-field').addEventListener('click', function() {
        newRow.remove();
    });

    elements.tagsTable.querySelector('tbody').appendChild(newRow);
}

function addCustomField() {
    const newRow = createTagRow('', '', false, true);
    elements.tagsTable.querySelector('tbody').appendChild(newRow);
}

function updateTag(row) {
    logDebug('Updating tag');
    const keyElement = row.querySelector('td:first-child');
    const keyInput = keyElement.querySelector('input');
    const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();

    const valueCell = row.querySelector('.tag-value-cell');
    const input = valueCell.querySelector('input, select');
    const value = input.value.trim();

    // Validate the value
    const areaTypeReqs = {{ area_type_requirements | tojson | safe }};
    const areaType = '{{ area.tags.get("type", "") }}';
    const requirements = areaTypeReqs[areaType]?.[key] || { type: 'text' };

    let finalValue = value;

    if (requirements.type === 'number' || requirements.type === 'integer') {
        const validation = validateNumericValue(value, requirements.type);
        if (!validation.isValid) {
            showToast('Error', validation.message, 'error');
            return;
        }
        finalValue = validation.value;  // Raw number
    }

    fetch('/api/set_area_tag', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            id: "{{ area.id }}",
            name: key,
            value: finalValue
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `HTTP error! status: ${response.status}`);
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.error) {
            throw new Error(data.error.message || 'Failed to update tag');
        }
        showToast('Success', 'Tag updated successfully', 'success');
    })
    .catch(error => {
        logDebug('Failed to update tag', error);
        showToast('Error', error.message, 'error');
    });
}

function handleTagsTableClick(e) {
    const target = e.target;
    if (!target.matches('button')) return;

    const row = target.closest('tr');
    if (!row) return;

    if (target.classList.contains('update-tag')) {
        updateTag(row);
    } else if (target.classList.contains('remove-field')) {
        const keyElement = row.querySelector('td:first-child');
        const keyInput = keyElement.querySelector('input');
        const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();

        showToast(
            'Confirm Delete',
            `Are you sure you want to remove the tag "${key}"?`,
            'warning',
            {
                confirmButtonText: 'Yes, delete it',
                cancelButtonText: 'Cancel',
                onConfirm: () => removeTag('{{ area.id }}', key)
            }
        );
    }
}

// Initialize everything after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    logDebug('DOM loaded, starting initialization');
    initializeEventListeners();
});

// Initialize map after all resources are loaded
window.addEventListener('load', () => {
    logDebug('Window loaded, initializing map');
    initializeMap();
});

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        logDebug('Page hidden, cleaning up map');
        if (map) {
            map.remove();
            map = null;
            mapInitialized = false;
        }
    } else if (!mapInitialized) {
        logDebug('Page visible, reinitializing map');
        initializeMap();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    logDebug('Page unloading, cleaning up map');
    if (map) {
        map.remove();
        map = null;
        mapInitialized = false;
    }
});
</script>
{% endblock %}