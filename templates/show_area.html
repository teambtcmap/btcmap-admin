{% extends "base.html" %}

{% block title %}Show Area{% endblock %}

{% block content %}
<div class="container">
    <div class="d-flex justify-content-between align-items-start mt-5 mb-4">
        <div>
            <h1 class="mb-1">Area Details</h1>
            <h2 class="mb-0">{{ area.tags.get('name', 'Unnamed Area') }} ({{ area.tags.get('type', 'Unknown Type') }})</h2>
        </div>
        <div class="position-relative area-icon-container">
            {% if area.tags.get('icon:square') %}
            <img id="area-icon" src="{{ area.tags.get('icon:square') }}" alt="{{ area.tags.get('name', 'Area') }} logo" style="max-width: 80px; max-height: 80px; object-fit: contain;">
            {% else %}
            <div id="area-icon-placeholder" class="d-flex align-items-center justify-content-center bg-secondary text-white" style="width: 80px; height: 80px;">
                <span>No Icon</span>
            </div>
            {% endif %}
            <button type="button" class="btn btn-sm btn-primary position-absolute edit-icon-btn" style="bottom: -8px; right: -8px; padding: 2px 6px; font-size: 0.7rem;" data-bs-toggle="modal" data-bs-target="#editIconModal">
                Edit
            </button>
        </div>
    </div>

    <!-- Edit Icon Modal -->
    <div class="modal fade" id="editIconModal" tabindex="-1" aria-labelledby="editIconModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editIconModalLabel">Edit Area Icon</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="iconFileInput" class="form-label">Upload Image</label>
                        <input type="file" class="form-control" id="iconFileInput" accept="image/png,image/jpeg,image/webp">
                        <div class="form-text">Accepted formats: PNG, JPG, WebP. The image will be cropped to a square.</div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Resolution Requirements</label>
                        <div class="form-text">
                            <strong>Minimum:</strong> 128 x 128 pixels<br>
                            <strong>Maximum:</strong> 1024 x 1024 pixels<br>
                            <strong>Output:</strong> Square image (1:1 aspect ratio)
                        </div>
                    </div>

                    <!-- Cropper Container -->
                    <div id="cropperContainer" class="mb-3" style="display: none;">
                        <label class="form-label">Crop Image (drag to pan, scroll to zoom)</label>
                        <div style="max-height: 400px; overflow: hidden;">
                            <img id="cropperImage" style="max-width: 100%;">
                        </div>
                    </div>

                    <!-- Preview -->
                    <div id="previewContainer" class="mb-3" style="display: none;">
                        <label class="form-label">Preview</label>
                        <div class="d-flex align-items-center gap-3">
                            <div>
                                <img id="iconPreview" style="width: 80px; height: 80px; object-fit: cover; border: 1px solid #dee2e6;">
                                <div class="form-text text-center">80px</div>
                            </div>
                            <div>
                                <img id="iconPreviewLarge" style="width: 128px; height: 128px; object-fit: cover; border: 1px solid #dee2e6;">
                                <div class="form-text text-center">128px</div>
                            </div>
                        </div>
                    </div>

                    <!-- Dimension Info -->
                    <div id="dimensionInfo" class="alert alert-info" style="display: none;">
                        <span id="dimensionText"></span>
                    </div>

                    <!-- Error Message -->
                    <div id="iconError" class="alert alert-danger" style="display: none;"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveIconBtn" disabled>Save Icon</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Lint Status Panel -->
    {% if lint_issues %}
    <div class="card mb-4 border-warning">
        <div class="card-header bg-warning bg-opacity-10">
            <h5 class="mb-0">
                <span class="text-warning">Maintenance Required</span>
                <span class="badge bg-warning text-dark ms-2">{{ lint_issues|length }}</span>
            </h5>
        </div>
        <div class="card-body">
            <ul class="list-group list-group-flush">
                {% for issue in lint_issues %}
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <span class="badge {% if issue.severity == 'error' %}bg-danger{% elif issue.severity == 'warning' %}bg-warning text-dark{% else %}bg-info{% endif %} me-2">
                            {{ issue.severity|upper }}
                        </span>
                        <strong>{{ issue.rule_name }}</strong>
                        <br>
                        <small class="text-muted">{{ issue.message }}</small>
                        {% if issue.current_value %}
                        <br><small class="text-muted font-monospace">Current: {{ issue.current_value|truncate(60) }}</small>
                        {% endif %}
                    </div>
                    {% if issue.auto_fixable %}
                    <button class="btn btn-sm btn-outline-success lint-fix-btn" 
                            data-fix-action="{{ issue.fix_action }}"
                            data-area-id="{{ area.id }}">
                        {% if issue.fix_action == 'migrate_icon' %}Migrate Icon{% elif issue.fix_action == 'bump_verified' %}Bump Verified{% else %}Fix{% endif %}
                    </button>
                    {% endif %}
                </li>
                {% endfor %}
            </ul>
        </div>
    </div>
    {% else %}
    <div class="alert alert-success mb-4">
        <strong>All checks passed</strong> - No maintenance required for this area.
    </div>
    {% endif %}

    <!-- Map container with consistent styling -->
    <div id="map-container" class="position-relative mb-4">
        <div id="map" style="height: 400px; width: 100%;"></div>
        <div class="position-absolute d-flex gap-2" style="top: 10px; right: 10px; z-index: 1000;">
            <button id="update-polygon-btn" class="btn btn-success btn-sm">Update</button>
            <button id="edit-geojson-btn" class="btn btn-primary btn-sm">Edit Raw GeoJSON</button>
        </div>
    </div>

    <!-- GeoJSON editor with improved styling -->
    <div id="geojson-editor" class="mb-4" style="display: none;">
        <textarea id="geojson-input" class="form-control mb-2" rows="5"></textarea>
        <div class="btn-group">
            <button id="show-btn" class="btn btn-primary">Show</button>
            <button id="update-btn" class="btn btn-success">Update</button>
            <button id="cancel-btn" class="btn btn-secondary">Cancel</button>
        </div>
    </div>

    <!-- Area information with card styling -->
    <div class="card mb-4">
        <div class="card-body">
            <table id="tags-table" class="table table-striped">
                <thead>
                    <tr>
                        <th>Key</th>
                        <th>Value</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for key, value in area.tags.items() %}
                        {% if key != 'geo_json' %}
                        <tr data-key="{{ key }}">
                            <td>{{ key }}</td>
                            <td class="tag-value-cell">
                                <span class="tag-value-content">{% if value is mapping %}[Object]{% else %}{{ value }}{% endif %}</span>
                                {% if key in area_type_requirements and area_type_requirements[key].get('allowed_values') %}
                                <select class="form-control tag-select d-none">
                                    {% for allowed_value in area_type_requirements[key].allowed_values %}
                                    <option value="{{ allowed_value }}" {% if allowed_value == value %}selected{% endif %}>{{ allowed_value }}</option>
                                    {% endfor %}
                                </select>
                                {% else %}
                                <input type="text" class="form-control tag-input d-none" value="{{ value if value is not mapping else '' }}">
                                {% endif %}
                                <div class="invalid-feedback"></div>
                            </td>
                            <td>
                                <div class="btn-group">
                                    <button class="btn btn-primary btn-sm edit-tag">Edit</button>
                                    <button class="btn btn-success btn-sm update-tag d-none">Update</button>
                                    <button class="btn btn-secondary btn-sm cancel-edit d-none">Cancel</button>
                                    {% if key not in area_type_requirements or not area_type_requirements[key].get('required', False) %}
                                    <button class="btn btn-danger btn-sm delete-tag">Remove</button>
                                    {% endif %}
                                </div>
                            </td>
                        </tr>
                        {% endif %}
                    {% endfor %}
                </tbody>
            </table>
            <div class="mt-3 text-center">
                <button type="button" id="add-optional-field-btn" class="btn btn-secondary">Add Optional Tag</button>
                <button type="button" id="add-custom-field-btn" class="btn btn-secondary">Add Custom Tag</button>
            </div>
        </div>
    </div>

    <!-- Centered and styled danger zone -->
    <div class="card text-center border-danger mt-5 mb-4">
        <div class="card-header bg-danger text-white">
            <h3 class="mb-0">Danger Zone</h3>
        </div>
        <div class="card-body">
            <p class="text-muted mb-3">Once you delete an area, there is no going back. Please be certain.</p>
            <button class="btn btn-danger btn-lg" onclick="removeArea('{{ area.id }}')">Remove Area</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="{{ url_for('static', filename='js/validation.js') }}"></script>
<script>
// Global variables
let map;
let geoJsonLayer;
let mapInitialized = false;
const elements = {
    mapContainer: document.getElementById('map'),
    editGeoJsonBtn: document.getElementById('edit-geojson-btn'),
    updatePolygonBtn: document.getElementById('update-polygon-btn'),
    geoJsonEditor: document.getElementById('geojson-editor'),
    geoJsonInput: document.getElementById('geojson-input'),
    showBtn: document.getElementById('show-btn'),
    updateBtn: document.getElementById('update-btn'),
    cancelBtn: document.getElementById('cancel-btn'),
    tagsTable: document.getElementById('tags-table')
};

// Debug logging function
function logDebug(message, error = null) {
    console.log(`[Debug] ${message}`);
    if (error) {
        console.error('[Error]', error);
    }
}

// Map initialization
function initializeMap() {
    try {
        logDebug('Initializing map...');
        if (!elements.mapContainer) {
            throw new Error('Map container not found');
        }

        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Initialize draw control
        window.drawnItems = new L.FeatureGroup();
        map.addLayer(window.drawnItems);

        var drawControl = new L.Control.Draw({
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    shapeOptions: {
                        color: '#3388ff',
                        weight: 3
                    }
                },
                rectangle: {
                    shapeOptions: {
                        color: '#3388ff',
                        weight: 3
                    }
                },
                circle: false,
                circlemarker: false,
                marker: false,
                polyline: false
            },
            edit: {
                featureGroup: window.drawnItems,
                remove: true,
                edit: true
            }
        });
        map.addControl(drawControl);

        // Handle draw created
        map.on(L.Draw.Event.CREATED, function(e) {
            var layer = e.layer;
            window.drawnItems.addLayer(layer);
            window.drawnItems.eachLayer(function(l) {
                window.drawnItems.removeLayer(l);
            });
            window.drawnItems.addLayer(layer);
            updateGeoJsonFromDrawnItems();
            showToast('Success', 'New polygon created', 'success');
        });

// Handle draw edited
map.on(L.Draw.Event.EDITED, function(e) {
    updateGeoJsonFromDrawnItems();
});

// Handle draw deleted
map.on(L.Draw.Event.DELETED, function(e) {
    currentGeoJson = null;
    if (geoJsonLayer) {
        map.removeLayer(geoJsonLayer);
        geoJsonLayer = null;
    }
});

        const geoJson = {{ geo_json | tojson | safe if geo_json else 'null' }};
        console.log('GeoJSON loaded from backend:', geoJson);

        if (geoJson) {
            updateMapWithGeoJson(geoJson);
            // Also add to drawnItems to make it editable
            setTimeout(() => {
                if (geoJsonLayer && geoJsonLayer.getLayers().length > 0) {
                    window.drawnItems.addLayer(geoJsonLayer.getLayers()[0]);
                    console.log('Added existing polygon to drawnItems for editing');
                    console.log('drawnItems layers count:', window.drawnItems.getLayers().length);
                }
            }, 100);
        }

        mapInitialized = true;
        logDebug('Map initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize map', error);
        showToast('Error', 'Failed to initialize map: ' + error.message, 'error');
    }
}

function updateGeoJsonFromDrawnItems() {
    if (window.drawnItems.getLayers().length === 0) {
        currentGeoJson = null;
        elements.geoJsonInput.value = '';
        return;
    }

    var layer = window.drawnItems.getLayers()[0];
    var geoJson = layer.toGeoJSON();
    currentGeoJson = geoJson.geometry;

    // Always update geojson input to keep text and graphical in sync
    elements.geoJsonInput.value = JSON.stringify(currentGeoJson, null, 2);

    map.fitBounds(window.drawnItems.getBounds());
}

// Update map with GeoJSON
function updateMapWithGeoJson(geoJson) {
    try {
        logDebug('Updating map with GeoJSON input:', geoJson);

        // Remove existing layer
        if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
        }

        // Clear drawn items
        if (window.drawnItems) {
            window.drawnItems.clearLayers();
        }

        // Handle string input
        if (typeof geoJson === 'string') {
            geoJson = JSON.parse(geoJson);
        }

        // Extract geometry if wrapped in Feature
        let geometry = geoJson;
        if (geoJson.type === 'Feature') {
            geometry = geoJson.geometry;
        } else if (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0) {
            geometry = geoJson.features[0].geometry;
        }

        // Store just the geometry
        currentGeoJson = geometry;

        logDebug('Adding GeoJSON to map:', geoJson);

        // Wrap as Feature for display in Leaflet
        const featureCollection = {
            "type": "Feature",
            "geometry": geometry
        };

        geoJsonLayer = L.geoJSON(featureCollection).addTo(map);
        map.fitBounds(geoJsonLayer.getBounds());

        // Also add to drawnItems for editing
        if (window.drawnItems && geoJsonLayer.getLayers().length > 0) {
            const layer = geoJsonLayer.getLayers()[0];
            window.drawnItems.addLayer(layer);
            console.log('Layer added to drawnItems for editing:', layer);
        }

        // Update textarea with current GeoJSON (keep them in sync)
        elements.geoJsonInput.value = JSON.stringify(currentGeoJson, null, 2);

        logDebug('GeoJSON updated successfully');
        return true;
    } catch (error) {
        logDebug('Failed to update GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
        return false;
    }
}

// Initialize event listeners
function initializeEventListeners() {
    try {
        logDebug('Initializing event listeners');

        // GeoJSON editor buttons
        if (elements.updatePolygonBtn) {
            elements.updatePolygonBtn.addEventListener('click', function() {
                updateGeoJsonFromDrawnItems();
                updateGeoJson();
            });
        }
        if (elements.editGeoJsonBtn) {
            elements.editGeoJsonBtn.addEventListener('click', startGeoJsonEditing);
        }
        if (elements.showBtn) {
            elements.showBtn.addEventListener('click', showGeoJson);
        }
        if (elements.updateBtn) {
            elements.updateBtn.addEventListener('click', updateGeoJson);
        }
        if (elements.cancelBtn) {
            elements.cancelBtn.addEventListener('click', cancelGeoJsonEditing);
        }

        // Add Optional and Custom Field buttons
        const addOptionalFieldBtn = document.getElementById('add-optional-field-btn');
        const addCustomFieldBtn = document.getElementById('add-custom-field-btn');

        if (addOptionalFieldBtn) {
            addOptionalFieldBtn.addEventListener('click', addOptionalField);
        }
        if (addCustomFieldBtn) {
            addCustomFieldBtn.addEventListener('click', addCustomField);
        }

        // Tags table event delegation
        if (elements.tagsTable) {
            elements.tagsTable.addEventListener('click', handleTagsTableClick);
        }

        logDebug('Event listeners initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize event listeners', error);
        showToast('Error', 'Failed to initialize event listeners: ' + error.message, 'error');
    }
}

function getExistingKeys() {
    const keys = [];
    elements.tagsTable.querySelectorAll('tbody tr').forEach(row => {
        const keyElement = row.querySelector('td:first-child');
        if (!keyElement) return;
        const keyInput = keyElement.querySelector('input');
        const key = keyInput ? keyInput.value.trim() : keyElement.textContent.trim();
        if (key) {
            keys.push(key);
        }
    });
    return keys;
}

function addOptionalField() {
    const areaType = '{{ area.tags.get("type", "") }}';
    if (!areaType) {
        showToast('Error', 'Area type not found', 'error');
        return;
    }

    const existingKeys = getExistingKeys();
    const areaTypeRequirements = {{ area_type_requirements | tojson | safe }};
    const optionalFields = Object.entries(areaTypeRequirements)
        .filter(([key, req]) => !req.required && !existingKeys.includes(key))
        .map(([key]) => key);

    if (optionalFields.length === 0) {
        showToast('Info', 'All optional fields have been added', 'info');
        return;
    }

    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td>
            <select class="form-control optional-field-select" required>
                <option value="">Select Tag</option>
                ${optionalFields.map(field => `<option value="${field}">${field}</option>`).join('')}
            </select>
            <div class="invalid-feedback">Please select a field</div>
        </td>
        <td>
            <input type="text" class="form-control" disabled>
            <div class="invalid-feedback">Please enter a valid value</div>
        </td>
        <td>
            <button type="button" class="btn btn-danger btn-sm remove-field">Remove</button>
        </td>
    `;

    const optionalFieldSelect = newRow.querySelector('.optional-field-select');
    optionalFieldSelect.addEventListener('change', function() {
        const selectedField = this.value;
        if (!selectedField) return;

        const requirements = areaTypeRequirements[selectedField];
        const row = createTagRow(
            selectedField,
            '',
            false,
            false,
            requirements.allowed_values
        );
        elements.tagsTable.querySelector('tbody').replaceChild(row, newRow);
    });

    newRow.querySelector('.remove-field').addEventListener('click', () => newRow.remove());
    elements.tagsTable.querySelector('tbody').appendChild(newRow);
}

function createTagRow(key, value = '', isRequired = false, isCustom = false, allowedValues = null) {
    const row = document.createElement('tr');
    const isNumericField = key === 'population' || key === 'area_km2';

    row.setAttribute('data-key', isCustom ? '' : key);
    row.innerHTML = `
        <td>
            ${isCustom ? 
                `<input type="text" class="form-control custom-key" placeholder="Tag Name" required>
                 <div class="invalid-feedback">Please enter a valid key</div>` 
                : key}
        </td>
        <td class="tag-value-cell">
            ${allowedValues ? `
                <select class="form-control tag-select">
                    <option value="">Select ${key}</option>
                    ${allowedValues.map(val => `<option value="${val}">${val}</option>`).join('')}
                </select>
            ` : `
                <input type="${isNumericField ? 'number' : 'text'}" 
                       class="form-control${isNumericField ? ' numeric-field' : ''}" 
                       value="${value}"
                       ${isNumericField ? `min="0" step="${key === 'population' ? '1' : '0.01'}"` : ''}>
            `}
            <div class="invalid-feedback"></div>
        </td>
        <td>
            <div class="btn-group">
                <button class="btn btn-success btn-sm update-tag">Update</button>
                <button class="btn btn-secondary btn-sm cancel-edit">Cancel</button>
                <button class="btn btn-danger btn-sm remove-field">Remove</button>
            </div>
        </td>
    `;

    if (isCustom) {
        const keyInput = row.querySelector('.custom-key');
        keyInput.addEventListener('input', function() {
            this.classList.remove('is-invalid');
            const feedback = this.nextElementSibling;
            if (feedback) {
                feedback.style.display = 'none';
            }
        });
        keyInput.addEventListener('blur', function() {
            validateCustomKey(this);
        });
    }

    const removeBtn = row.querySelector('.remove-field');
    if (removeBtn) {
        removeBtn.addEventListener('click', () => row.remove());
    }

    const updateBtn = row.querySelector('.update-tag');
    if (updateBtn) {
        updateBtn.addEventListener('click', () => updateTag(row));
    }

    const cancelBtn = row.querySelector('.cancel-edit');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => row.remove());
    }

    return row;
}

function addCustomField() {
    const newRow = createTagRow('', '', false, true);
    elements.tagsTable.querySelector('tbody').appendChild(newRow);
}

function validateCustomKey(keyInput) {
    const key = keyInput.value.trim();
    const validation = validateKey(key, getExistingKeys());
    const feedback = keyInput.nextElementSibling;

    keyInput.classList.toggle('is-invalid', !validation.isValid);
    if (feedback && feedback.classList.contains('invalid-feedback')) {
        feedback.textContent = validation.message;
        feedback.style.display = validation.isValid ? 'none' : 'block';
    }

    if (!validation.isValid) {
        showToast('Error', validation.message, 'error');
    }

    return validation.isValid;
}

// GeoJSON editing functions
function startGeoJsonEditing() {
    logDebug('Starting GeoJSON editing');
    elements.geoJsonEditor.style.display = 'block';

    // Try to get GeoJSON from drawnItems first, otherwise from geoJsonLayer
    let geoJson;
    if (window.drawnItems && window.drawnItems.getLayers().length > 0) {
        geoJson = window.drawnItems.getLayers()[0].toGeoJSON();
    } else if (geoJsonLayer) {
        geoJson = geoJsonLayer.toGeoJSON();
    }

    if (geoJson) {
        const geometry = geoJson.type === 'FeatureCollection'
            ? geoJson.features[0].geometry
            : geoJson.type === 'Feature'
                ? geoJson.geometry
                : geoJson;
        elements.geoJsonInput.value = JSON.stringify(geometry, null, 2);
    }
}

function showGeoJson() {
    try {
        const geoJson = JSON.parse(elements.geoJsonInput.value);
        if (updateMapWithGeoJson(geoJson)) {
            showToast('Success', 'GeoJSON preview updated', 'success');
        }
    } catch (error) {
        logDebug('Failed to show GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function updateGeoJson() {
    try {
        logDebug('Starting GeoJSON update');
        const rawInput = elements.geoJsonInput.value;

        console.log('=== CLIENT: Textarea value before send ===');
        console.log('Raw textarea:', rawInput);

        // Parse the input to get a clean object
        let geoJson = JSON.parse(rawInput);

        console.log('=== CLIENT: Parsed JSON ===');
        console.log('Type:', geoJson.type);
        console.log('Keys:', Object.keys(geoJson));
        console.log('Full object:', geoJson);

        // ALWAYS extract just the geometry (ignore any Feature wrappers)
        // This ensures only "type" and "coordinates" are sent to server
        let geometry = geoJson;
        if (geoJson.type === 'Feature' && geoJson.geometry) {
            console.log('=== CLIENT: Extracting geometry from Feature ===');
            geometry = geoJson.geometry;
        } else if (geoJson.type === 'FeatureCollection' && geoJson.features && geoJson.features.length > 0 && geoJson.features[0].geometry) {
            console.log('=== CLIENT: Extracting geometry from FeatureCollection ===');
            geometry = geoJson.features[0].geometry;
        }

        console.log('=== CLIENT: Geometry being sent ===');
        console.log('Type:', geometry.type);
        console.log('Keys:', Object.keys(geometry));
        console.log('Value:', JSON.stringify(geometry, null, 2));
        logDebug('Extracted geometry:', geometry);

        const payload = {
            id: '{{ area.id }}',
            name: 'geo_json',
            value: geometry  // Send ONLY the geometry (type + coordinates)
        };

        console.log('=== CLIENT: Full payload being sent ===');
        console.log(JSON.stringify(payload, null, 2));

        fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
            .then(response => {
                console.log('=== CLIENT: Response received ===');
                console.log('Status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('=== CLIENT: Response data ===');
                console.log(data);

                if (data.error) {
                    throw new Error(data.error || 'Failed to update GeoJSON');
                }
                logDebug('GeoJSON successfully updated on server');
                showToast('Success', 'GeoJSON updated successfully', 'success');
                elements.geoJsonEditor.style.display = 'none';
                // Refresh the map with the updated GeoJSON
                updateMapWithGeoJson(geometry);
            })
            .catch(error => {
                console.log('=== CLIENT: Error ===');
                console.error(error);
                logDebug('Failed to update GeoJSON on server', error);
                showToast('Error', error.message || 'Failed to update GeoJSON', 'error');
            });
    } catch (error) {
        console.log('=== CLIENT: Exception ===');
        console.error(error);
        logDebug('Failed to process GeoJSON input', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function cancelGeoJsonEditing() {
    elements.geoJsonEditor.style.display = 'none';
}

// Tag editing functions
function startEditing(row) {
    logDebug('Starting tag editing');
    const valueCell = row.querySelector('.tag-value-cell');
    const content = valueCell.querySelector('.tag-value-content');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const editBtn = row.querySelector('.edit-tag');
    const updateBtn = row.querySelector('.update-tag');
    const cancelBtn = row.querySelector('.cancel-edit');

    content.classList.add('d-none');
    if (input) {
        input.classList.remove('d-none');
        input.value = content.textContent.trim();
    }
    if (select) {
        select.classList.remove('d-none');
    }
    editBtn.classList.add('d-none');
    updateBtn.classList.remove('d-none');
    cancelBtn.classList.remove('d-none');
}

function updateTag(row) {
    logDebug('Updating tag');
    const key = row.dataset.key;
    const valueCell = row.querySelector('.tag-value-cell');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const content = valueCell.querySelector('.tag-value-content');

    let value = (input && !input.classList.contains('d-none')) ? input.value :
        (select && !select.classList.contains('d-none')) ? select.value :
            content.textContent;

    // Validate the value
    const requirements = {{ area_type_requirements | tojson | safe }}[key] || {};
    let validation;
    let finalValue;

    if (requirements.type === 'number' || requirements.type === 'integer') {
        validation = validateNumericValue(value, requirements.type);
        if (!validation.isValid) {
            showToast('Error', validation.message, 'error');
            return;
        }
        // Keep the numeric value for display
        value = validation.value;
        // Send number as raw value to RPC
        finalValue = validation.value;  // Raw number
    } else {
        validation = validateValue(value, requirements);
        if (!validation.isValid) {
            showToast('Error', validation.message, 'error');
            return;
        }
        finalValue = value;  // String value
    }

    // For GeoJSON, parse and send as raw object
    if (key === 'geo_json' && typeof finalValue === 'string') {
        try {
            // Parse to validate and send as raw object
            finalValue = JSON.parse(finalValue);
        } catch (error) {
            showToast('Error', 'Invalid GeoJSON format', 'error');
            return;
        }
    }

    console.log("Tag data to be sent:", {id: "{{ area.id }}", name: key, value: finalValue}); //Added console log

    fetch('/api/set_area_tag', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            id: "{{ area.id }}",    // Values as quoted strings
            name: key,              // Tag name as raw (unquoted)
            value: finalValue       // Raw for numbers/objects, quoted for strings
        })
    })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `HTTP error! status: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                throw new Error(data.error.message || 'Failed to update tag');
            }
            content.textContent = value;  // Display the properly typed value
            cancelEditing(row);
            showToast('Success', 'Tag updated successfully', 'success');
        })
        .catch(error => {
            logDebug('Failed to update tag', error);
            showToast('Error', error.message, 'error');
        });
}

function cancelEditing(row) {
    logDebug('Canceling tag editing');
    const valueCell = row.querySelector('.tag-value-cell');
    const content = valueCell.querySelector('.tag-value-content');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const editBtn = row.querySelector('.edit-tag');
    const updateBtn = row.querySelector('.update-tag');
    const cancelBtn = row.querySelector('.cancel-edit');

    content.classList.remove('d-none');
    if (input) input.classList.add('d-none');
    if (select) select.classList.add('d-none');
    editBtn.classList.remove('d-none');
    updateBtn.classList.add('d-none');
    cancelBtn.classList.add('d-none');

    // Reset validation state
    if (input) {
        input.classList.remove('is-invalid');
        const feedback = valueCell.querySelector('.invalid-feedback');
        if (feedback) {
            feedback.style.display = 'none';
        }
    }
}

function handleTagsTableClick(e) {
    const target = e.target;
    if (!target.matches('button')) return;

    const row = target.closest('tr');
    if (!row) return;

    if (target.classList.contains('edit-tag')) {
        startEditing(row);
    } else if (target.classList.contains('update-tag')) {
        updateTag(row);
    } else if (target.classList.contains('cancel-edit')) {
        cancelEditing(row);
    } else if (target.classList.contains('delete-tag')) {
        const key = row.dataset.key;
        showToast(
            'Confirm Delete',
            `Are you sure you want to remove the tag "${key}"?`,
            'warning',
            {
                confirmButtonText: 'Yes, delete it',
                cancelButtonText: 'Cancel',
                onConfirm: () => removeTag('{{ area.id }}', key)
            }
        );
    }
}

// Initialize everything after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    logDebug('DOM loaded, starting initialization');
    initializeEventListeners();
});

// Initialize map after all resources are loaded
window.addEventListener('load', () => {
    logDebug('Window loaded, initializing map');
    initializeMap();
});

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        logDebug('Page hidden, cleaning up map');
        if (map) {
            map.remove();
            map = null;
            mapInitialized = false;
        }
    } else if (!mapInitialized) {
        logDebug('Page visible, reinitializing map');
        initializeMap();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    logDebug('Page unloading, cleaning up map');
    if (map) {
        map.remove();
        map = null;
        mapInitialized = false;
    }
});

// ============================================
// Icon Editor Functionality
// ============================================

const ICON_MIN_SIZE = 128;
const ICON_MAX_SIZE = 1024;
const ICON_OUTPUT_SIZE = 256; // Output size for the cropped image

let cropper = null;
let currentFile = null;

const iconElements = {
    fileInput: null,
    cropperContainer: null,
    cropperImage: null,
    previewContainer: null,
    iconPreview: null,
    iconPreviewLarge: null,
    dimensionInfo: null,
    dimensionText: null,
    iconError: null,
    saveIconBtn: null,
    modal: null
};

function initializeIconEditor() {
    iconElements.fileInput = document.getElementById('iconFileInput');
    iconElements.cropperContainer = document.getElementById('cropperContainer');
    iconElements.cropperImage = document.getElementById('cropperImage');
    iconElements.previewContainer = document.getElementById('previewContainer');
    iconElements.iconPreview = document.getElementById('iconPreview');
    iconElements.iconPreviewLarge = document.getElementById('iconPreviewLarge');
    iconElements.dimensionInfo = document.getElementById('dimensionInfo');
    iconElements.dimensionText = document.getElementById('dimensionText');
    iconElements.iconError = document.getElementById('iconError');
    iconElements.saveIconBtn = document.getElementById('saveIconBtn');
    iconElements.modal = document.getElementById('editIconModal');

    if (!iconElements.fileInput) return;

    iconElements.fileInput.addEventListener('change', handleFileSelect);
    iconElements.saveIconBtn.addEventListener('click', saveIcon);

    // Reset modal state when closed
    iconElements.modal.addEventListener('hidden.bs.modal', resetIconEditor);
}

function resetIconEditor() {
    if (cropper) {
        cropper.destroy();
        cropper = null;
    }
    currentFile = null;
    iconElements.fileInput.value = '';
    iconElements.cropperContainer.style.display = 'none';
    iconElements.previewContainer.style.display = 'none';
    iconElements.dimensionInfo.style.display = 'none';
    iconElements.iconError.style.display = 'none';
    iconElements.saveIconBtn.disabled = true;
}

function showIconError(message) {
    iconElements.iconError.textContent = message;
    iconElements.iconError.style.display = 'block';
    iconElements.saveIconBtn.disabled = true;
}

function hideIconError() {
    iconElements.iconError.style.display = 'none';
}

function handleFileSelect(e) {
    const file = e.target.files[0];
    if (!file) return;

    hideIconError();

    // Validate file type
    const validTypes = ['image/png', 'image/jpeg', 'image/webp'];
    if (!validTypes.includes(file.type)) {
        showIconError('Invalid file type. Please upload a PNG, JPG, or WebP image.');
        return;
    }

    currentFile = file;

    const reader = new FileReader();
    reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
            // Check minimum dimensions
            if (img.width < ICON_MIN_SIZE || img.height < ICON_MIN_SIZE) {
                showIconError(`Image is too small. Minimum size is ${ICON_MIN_SIZE}x${ICON_MIN_SIZE} pixels. Your image is ${img.width}x${img.height} pixels.`);
                return;
            }

            // Check maximum dimensions
            if (img.width > 4096 || img.height > 4096) {
                showIconError(`Image is too large. Maximum size is 4096x4096 pixels. Your image is ${img.width}x${img.height} pixels.`);
                return;
            }

            // Show dimension info
            iconElements.dimensionText.textContent = `Original size: ${img.width} x ${img.height} pixels`;
            iconElements.dimensionInfo.style.display = 'block';

            // Initialize cropper
            initializeCropper(event.target.result);
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

function initializeCropper(imageSrc) {
    // Destroy existing cropper
    if (cropper) {
        cropper.destroy();
    }

    iconElements.cropperImage.src = imageSrc;
    iconElements.cropperContainer.style.display = 'block';

    cropper = new Cropper(iconElements.cropperImage, {
        aspectRatio: 1, // Force square
        viewMode: 1,
        dragMode: 'move',
        autoCropArea: 1,
        restore: false,
        guides: true,
        center: true,
        highlight: false,
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
        minCropBoxWidth: ICON_MIN_SIZE,
        minCropBoxHeight: ICON_MIN_SIZE,
        ready: function() {
            updatePreview();
            iconElements.saveIconBtn.disabled = false;
        },
        crop: function() {
            updatePreview();
        }
    });
}

function updatePreview() {
    if (!cropper) return;

    const canvas = cropper.getCroppedCanvas({
        width: ICON_OUTPUT_SIZE,
        height: ICON_OUTPUT_SIZE,
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high'
    });

    if (canvas) {
        const dataUrl = canvas.toDataURL('image/png');
        iconElements.iconPreview.src = dataUrl;
        iconElements.iconPreviewLarge.src = dataUrl;
        iconElements.previewContainer.style.display = 'block';
    }
}

function getFileExtension(file) {
    const type = file.type;
    switch (type) {
        case 'image/png': return 'png';
        case 'image/jpeg': return 'jpg';
        case 'image/webp': return 'webp';
        default: return 'png';
    }
}

async function saveIcon() {
    if (!cropper || !currentFile) {
        showIconError('No image selected');
        return;
    }

    hideIconError();
    iconElements.saveIconBtn.disabled = true;
    iconElements.saveIconBtn.textContent = 'Saving...';

    try {
        // Get cropped canvas at output size
        const canvas = cropper.getCroppedCanvas({
            width: ICON_OUTPUT_SIZE,
            height: ICON_OUTPUT_SIZE,
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high'
        });

        if (!canvas) {
            throw new Error('Failed to crop image');
        }

        // Validate final dimensions
        if (canvas.width < ICON_MIN_SIZE || canvas.height < ICON_MIN_SIZE) {
            throw new Error(`Cropped area is too small. Please select a larger area (minimum ${ICON_MIN_SIZE}x${ICON_MIN_SIZE} pixels).`);
        }

        // Convert to blob then base64
        const blob = await new Promise((resolve, reject) => {
            canvas.toBlob(
                (b) => b ? resolve(b) : reject(new Error('Failed to create image blob')),
                'image/png',
                1.0
            );
        });

        // Convert blob to base64
        const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // Remove the data URL prefix to get just the base64 data
                const base64Data = reader.result.split(',')[1];
                resolve(base64Data);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });

        // Send to API
        const response = await fetch('/api/set_area_icon', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: '{{ area.id }}',
                icon_base64: base64,
                icon_ext: 'png'
            })
        });

        const data = await response.json();

        if (!response.ok || data.error) {
            throw new Error(data.error || 'Failed to update icon');
        }

        // Success - close modal and update the displayed icon
        const modal = bootstrap.Modal.getInstance(iconElements.modal);
        modal.hide();

        // Update the icon on the page
        const areaIcon = document.getElementById('area-icon');
        const iconPlaceholder = document.getElementById('area-icon-placeholder');
        
        if (areaIcon) {
            // Add cache-busting parameter
            const newSrc = data.result?.tags?.['icon:square'] || (areaIcon.src.split('?')[0] + '?t=' + Date.now());
            areaIcon.src = newSrc;
        } else if (iconPlaceholder) {
            // Replace placeholder with actual image
            const newImg = document.createElement('img');
            newImg.id = 'area-icon';
            newImg.alt = '{{ area.tags.get("name", "Area") }} logo';
            newImg.style.cssText = 'max-width: 80px; max-height: 80px; object-fit: contain;';
            newImg.src = data.result?.tags?.['icon:square'] || '';
            iconPlaceholder.parentNode.replaceChild(newImg, iconPlaceholder);
        }

        showToast('Success', 'Icon updated successfully', 'success');

    } catch (error) {
        console.error('Error saving icon:', error);
        showIconError(error.message || 'Failed to save icon');
    } finally {
        iconElements.saveIconBtn.disabled = false;
        iconElements.saveIconBtn.textContent = 'Save Icon';
    }
}

// Initialize icon editor when DOM is ready
document.addEventListener('DOMContentLoaded', initializeIconEditor);

// ============================================
// Lint Fix Handlers
// ============================================

document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.lint-fix-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
            const areaId = this.dataset.areaId;
            const fixAction = this.dataset.fixAction;
            const originalText = this.textContent;
            
            this.disabled = true;
            this.textContent = 'Fixing...';

            try {
                const response = await fetch('/api/lint/fix', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ area_id: areaId, fix_action: fixAction })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showToast('Success', data.message || 'Fixed successfully', 'success');
                    // Reload page to show updated lint status
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    showToast('Error', data.error || 'Fix failed', 'error');
                    this.disabled = false;
                    this.textContent = originalText;
                }
            } catch (error) {
                console.error('Error fixing:', error);
                showToast('Error', 'Failed to apply fix', 'error');
                this.disabled = false;
                this.textContent = originalText;
            }
        });
    });
});
</script>
{% endblock %}